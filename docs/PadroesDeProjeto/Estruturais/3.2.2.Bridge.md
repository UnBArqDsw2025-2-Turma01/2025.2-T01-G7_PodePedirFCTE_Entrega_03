# GoF Estrutural - Bridge

O padrão Bridge pertence à categoria dos padrões estruturais e tem como principal objetivo separar uma abstração de sua implementação, permitindo que ambas evoluam de forma independente.

Em sistemas orientados a objetos, é comum que uma abstração (como um “Controle”, “Ferramenta” ou “Interface Gráfica”) esteja diretamente acoplada a uma implementação específica. Esse acoplamento rígido dificulta mudanças, amplia a complexidade e reduz a reutilização.
O Bridge surge justamente para resolver esse problema: ele cria uma ponte entre a abstração e sua implementação, tornando possível alterar uma sem impactar a outra.

---

## Intuito Padrão

O intuito do GoF Bridge é desacoplar o “o que” do “como”, permitindo que novas variações de abstrações e implementações sejam combinadas livremente, sem explosão de subclasses e sem reescrever código existente.

Em outras palavras, ele estabelece uma relação de composição entre a abstração e sua implementação — em vez de herança direta —, criando um elo de flexibilidade.
Assim, uma classe de alto nível (a abstração) define o comportamento principal, enquanto delega os detalhes técnicos de execução para um objeto implementador.

---

## Estrutura Conceitual

O Bridge é formado por quatro papéis fundamentais:

| Papel                   | Descrição                                                                                                       |
| ----------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Abstraction**         | Define a interface principal usada pelos clientes e mantém uma referência para um objeto do tipo *Implementor*. |
| **RefinedAbstraction**  | É uma extensão da abstração principal, adicionando ou refinando comportamentos.                                 |
| **Implementor**         | Define a interface para as classes concretas que irão implementar as funcionalidades reais.                     |
| **ConcreteImplementor** | Implementa efetivamente as operações declaradas por *Implementor*, podendo variar conforme o contexto.          |

Com essa estrutura, a abstração lida com a lógica de controle, enquanto a implementação lida com a execução real.

---

## Benefícios do Uso

- Desacoplamento total entre abstração e implementação.

- Facilidade de extensão: novas abstrações ou implementações podem ser adicionadas sem alterar o código existente.

- Redução do acoplamento rígido, favorecendo a manutenção e a testabilidade.

- Combinação flexível: permite misturar diferentes abstrações com diferentes implementações.

---

## Aplicação no projeto

Com base no cenário de estudo proposto para esta disciplina, foi criado a seguinte estrutura de código para ilustrar a sua aplicação, levando em consideração o [Diagrama de Classes](#) da entrega 2.

### Bridge - Pode pedir FCTE

No contexto do PodePedirFCTE, o padrão Bridge foi aplicado para desacoplar a abstração “Comprovante de Pedido” (a forma lógica de gerar um recibo de compra) da implementação “Canal de Envio” (o meio técnico pelo qual esse comprovante é entregue ao cliente).

A motivação foi clara: em um sistema de delivery moderno, o mesmo tipo de comprovante pode ser enviado por diferentes canais — WhatsApp, e-mail, webhook, SMS, etc. Se o código estivesse rigidamente acoplado, seria necessário criar uma classe específica para cada combinação possível, como ComprovanteBasicoWhatsApp, ComprovanteDetalhadoEmail, ComprovanteFiscalWebhook e assim por diante. Isso geraria explosão de subclasses e alta complexidade de manutenção.

Ao adotar o Bridge, criamos duas hierarquias independentes:

- Abstração → Comprovante, ComprovanteBasico, ComprovanteDetalhado
Responsável por definir o que deve ser enviado (estrutura e formato do comprovante).

- Implementação → CanalEnvio, WhatsAppCanal, EmailCanal, WebhookCanal
Responsável por definir como a mensagem será transmitida.

A abstração mantém apenas uma referência genérica a um CanalEnvio. Assim, o mesmo comprovante pode ser utilizado com qualquer canal, e novos canais podem ser adicionados sem alterar as classes de comprovante — basta “trocar a ponte”.

Na execução, o objeto ComprovanteDetalhado monta o conteúdo textual do pedido e o delega ao canal configurado (por exemplo, EmailCanal) para envio. Posteriormente, ele pode mudar dinamicamente para outro canal (WebhookCanal) sem qualquer modificação estrutural, apenas chamando o método trocarCanal().

Essa aplicação ilustra perfeitamente o princípio descrito no padrão Bridge: permitir que abstrações e implementações variem independentemente, tornando o sistema mais modular, extensível e fácil de evoluir.

Em resumo, o Bridge no PodePedirFCTE garante que o conceito de “comprovante” e o mecanismo de “entrega” possam evoluir separadamente — por exemplo, permitindo criar novos tipos de comprovante (fiscal, resumido, promocional) e novos canais (push, chatbot, integração ERP) sem quebrar o código existente, mantendo o sistema flexível e preparado para futuras expansões.

---

#### Estrutura Sugerida

```md
podepedir-bridge/
  src/
    domain.ts
    bridge/
      implementor.ts       # Implementor + ConcreteImplementors (canais)
      abstraction.ts       # Abstraction + RefinedAbstractions (comprovantes)
    main.ts
  package.json
  tsconfig.json
```

#### 1) package.json

```json
{
  "name": "podepedir-bridge-demo",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "tsx src/main.ts",
    "dev": "tsx watch src/main.ts",
    "build": "tsc -p ."
  },
  "devDependencies": {
    "tsx": "^4.19.2",
    "typescript": "^5.6.3"
  }
}
```

#### 2) tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist"
  },
  "include": ["src"]
}
```

#### 3) src/domain.ts

```ts
export type ID = string | number;

export interface ItemPedido {
  id: ID;
  nome: string;
  qtd: number;
  preco: number; // unitário
}

export interface Pedido {
  id: ID;
  alunoNome: string;
  alunoContato: string;   // e-mail ou telefone
  fornecedorNome: string;
  taxaEntrega: number;
  itens: ItemPedido[];
  criadoEm: Date;
}

export function totalItens(p: Pedido) {
  return p.itens.reduce((s, i) => s + i.preco * i.qtd, 0);
}
export function totalGeral(p: Pedido) {
  return totalItens(p) + p.taxaEntrega;
}
```
#### 4) src/bridge/implementor.ts

```ts
// Implementor
export interface CanalEnvio {
  nome(): string;
  enviar(destino: string, conteudo: string, meta?: Record<string, unknown>): Promise<void>;
}

// ConcreteImplementor A: WhatsApp
export class WhatsAppCanal implements CanalEnvio {
  constructor(private fromNumber: string) {}
  nome() { return "WhatsApp"; }
  async enviar(destino: string, conteudo: string) {
    // simulação de integração
    console.log(`📱 [WhatsApp] ${this.fromNumber} → ${destino}\n${conteudo}\n`);
  }
}

// ConcreteImplementor B: Email
export class EmailCanal implements CanalEnvio {
  constructor(private remetente: string) {}
  nome() { return "Email"; }
  async enviar(destino: string, conteudo: string, meta?: Record<string, unknown>) {
    const assunto = meta?.assunto ?? "Comprovante do Pedido";
    console.log(`📧 [Email] ${this.remetente} → ${destino}\nAssunto: ${assunto}\n${conteudo}\n`);
  }
}

// ConcreteImplementor C: Webhook (ex.: ERP/CRM)
export class WebhookCanal implements CanalEnvio {
  constructor(private endpoint: string) {}
  nome() { return "Webhook"; }
  async enviar(destino: string, conteudo: string) {
    // simulação de POST
    console.log(`🔗 [Webhook] POST ${this.endpoint} (destino=${destino})\nPayload:\n${conteudo}\n`);
  }
}
```

#### 5) src/bridge/abstraction.ts

```ts
import { Pedido, totalGeral, totalItens } from "../domain";
import { CanalEnvio } from "./implementor";

// Abstraction
export abstract class Comprovante {
  constructor(protected canal: CanalEnvio) {}
  abstract montarConteudo(pedido: Pedido): string;

  async enviar(pedido: Pedido) {
    const conteudo = this.montarConteudo(pedido);
    await this.canal.enviar(pedido.alunoContato, conteudo, {
      assunto: `Comprovante do Pedido #${pedido.id}`,
    });
  }

  canalAtual() { return this.canal; }
  trocarCanal(novo: CanalEnvio) { this.canal = novo; }
}

// RefinedAbstraction A: Básico
export class ComprovanteBasico extends Comprovante {
  montarConteudo(p: Pedido): string {
    return [
      `Pedido #${p.id} — ${p.fornecedorNome}`,
      `Cliente: ${p.alunoNome}`,
      `Itens: ${p.itens.length} | Total Itens: R$ ${totalItens(p).toFixed(2)}`,
      `Taxa de entrega: R$ ${p.taxaEntrega.toFixed(2)}`,
      `Total: R$ ${totalGeral(p).toFixed(2)}`,
      `Criado em: ${p.criadoEm.toLocaleString()}`
    ].join("\n");
  }
}

// RefinedAbstraction B: Detalhado
export class ComprovanteDetalhado extends Comprovante {
  montarConteudo(p: Pedido): string {
    const itens = p.itens
      .map(i => ` - ${i.nome} x${i.qtd} = R$ ${(i.preco * i.qtd).toFixed(2)}`)
      .join("\n");
    return [
      `Pedido #${p.id}`,
      `Fornecedor: ${p.fornecedorNome}`,
      `Cliente: ${p.alunoNome}`,
      `\nItens:\n${itens}`,
      `\nSubtotal: R$ ${totalItens(p).toFixed(2)}`,
      `Taxa entrega: R$ ${p.taxaEntrega.toFixed(2)}`,
      `Total: R$ ${totalGeral(p).toFixed(2)}`,
      `Data/Hora: ${p.criadoEm.toLocaleString()}`
    ].join("\n");
  }
}
```

#### 6)src/main.ts

```ts
import { Pedido } from "./domain";
import { ComprovanteBasico, ComprovanteDetalhado } from "./bridge/abstraction";
import { EmailCanal, WhatsAppCanal, WebhookCanal } from "./bridge/implementor";

// Pedido de exemplo
const pedido: Pedido = {
  id: "P-2025-001",
  alunoNome: "Ana Silva",
  alunoContato: "ana.silva@fcte.br", // vai servir como "destino" genérico
  fornecedorNome: "Cantina FCTE",
  taxaEntrega: 5.9,
  criadoEm: new Date(),
  itens: [
    { id: "i1", nome: "X-FCTE", qtd: 1, preco: 22 },
    { id: "i2", nome: "Suco Laranja", qtd: 2, preco: 8 }
  ]
};

async function run() {
  // Implementations (canais)
  const zap = new WhatsAppCanal("+5561999999999");
  const email = new EmailCanal("no-reply@podepedir.fcte");
  const hook = new WebhookCanal("https://api.parceiro.dev/webhook/pedidos");

  // Abstraction 1 + Implementor A
  const compBasicoViaZap = new ComprovanteBasico(zap);
  await compBasicoViaZap.enviar({ ...pedido, alunoContato: "+5561988888888" });

  // Abstraction 2 + Implementor B
  const compDetalhadoViaEmail = new ComprovanteDetalhado(email);
  await compDetalhadoViaEmail.enviar(pedido);

  // Trocar implementação em tempo de execução (Bridge em ação)
  compDetalhadoViaEmail.trocarCanal(hook);
  await compDetalhadoViaEmail.enviar({ ...pedido, alunoContato: "erp.parceiro" });

  // Outra combinação ainda: Básico por Email
  compBasicoViaZap.trocarCanal(email);
  await compBasicoViaZap.enviar(pedido);
}

run().catch(console.error);
```

---

### Execução

O vídeo a seguir ilusta a execução do código acima. [Link de acesso.](#)

---

## Histórico de Versões

| **Data**       | **Versão** | **Descrição**                         | **Autor**                                      | **Revisor**                                      | **Data da Revisão** |
| :--------: | :----: | :-------------------------------- | :----------------------------------------: | :----------------------------------------: | :-------------: |
| 21/10/2025 |  `1.0`   | Criação da página. | [`@storch7`](https://github.com/storch7) | [`@`]() |   --/--/----    |
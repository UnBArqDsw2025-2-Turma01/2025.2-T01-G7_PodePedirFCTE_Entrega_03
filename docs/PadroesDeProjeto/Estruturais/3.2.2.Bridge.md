# GoF Estrutural - Bridge

O padr√£o Bridge pertence √† categoria dos padr√µes estruturais e tem como principal objetivo separar uma abstra√ß√£o de sua implementa√ß√£o, permitindo que ambas evoluam de forma independente.

Em sistemas orientados a objetos, √© comum que uma abstra√ß√£o (como um ‚ÄúControle‚Äù, ‚ÄúFerramenta‚Äù ou ‚ÄúInterface Gr√°fica‚Äù) esteja diretamente acoplada a uma implementa√ß√£o espec√≠fica. Esse acoplamento r√≠gido dificulta mudan√ßas, amplia a complexidade e reduz a reutiliza√ß√£o.
O Bridge surge justamente para resolver esse problema: ele cria uma ponte entre a abstra√ß√£o e sua implementa√ß√£o, tornando poss√≠vel alterar uma sem impactar a outra.

---

## Intuito Padr√£o

O intuito do GoF Bridge √© desacoplar o ‚Äúo que‚Äù do ‚Äúcomo‚Äù, permitindo que novas varia√ß√µes de abstra√ß√µes e implementa√ß√µes sejam combinadas livremente, sem explos√£o de subclasses e sem reescrever c√≥digo existente.

Em outras palavras, ele estabelece uma rela√ß√£o de composi√ß√£o entre a abstra√ß√£o e sua implementa√ß√£o ‚Äî em vez de heran√ßa direta ‚Äî, criando um elo de flexibilidade.
Assim, uma classe de alto n√≠vel (a abstra√ß√£o) define o comportamento principal, enquanto delega os detalhes t√©cnicos de execu√ß√£o para um objeto implementador.

---

## Estrutura Conceitual

O Bridge √© formado por quatro pap√©is fundamentais:

| Papel                   | Descri√ß√£o                                                                                                       |
| ----------------------- | --------------------------------------------------------------------------------------------------------------- |
| **Abstraction**         | Define a interface principal usada pelos clientes e mant√©m uma refer√™ncia para um objeto do tipo *Implementor*. |
| **RefinedAbstraction**  | √â uma extens√£o da abstra√ß√£o principal, adicionando ou refinando comportamentos.                                 |
| **Implementor**         | Define a interface para as classes concretas que ir√£o implementar as funcionalidades reais.                     |
| **ConcreteImplementor** | Implementa efetivamente as opera√ß√µes declaradas por *Implementor*, podendo variar conforme o contexto.          |

Com essa estrutura, a abstra√ß√£o lida com a l√≥gica de controle, enquanto a implementa√ß√£o lida com a execu√ß√£o real.

---

## Benef√≠cios do Uso

- Desacoplamento total entre abstra√ß√£o e implementa√ß√£o.

- Facilidade de extens√£o: novas abstra√ß√µes ou implementa√ß√µes podem ser adicionadas sem alterar o c√≥digo existente.

- Redu√ß√£o do acoplamento r√≠gido, favorecendo a manuten√ß√£o e a testabilidade.

- Combina√ß√£o flex√≠vel: permite misturar diferentes abstra√ß√µes com diferentes implementa√ß√µes.

---

## Aplica√ß√£o no projeto

Com base no cen√°rio de estudo proposto para esta disciplina, foi criado a seguinte estrutura de c√≥digo para ilustrar a sua aplica√ß√£o, levando em considera√ß√£o o [Diagrama de Classes](#) da entrega 2.

### Bridge - Pode pedir FCTE

No contexto do PodePedirFCTE, o padr√£o Bridge foi aplicado para desacoplar a abstra√ß√£o ‚ÄúComprovante de Pedido‚Äù (a forma l√≥gica de gerar um recibo de compra) da implementa√ß√£o ‚ÄúCanal de Envio‚Äù (o meio t√©cnico pelo qual esse comprovante √© entregue ao cliente).

A motiva√ß√£o foi clara: em um sistema de delivery moderno, o mesmo tipo de comprovante pode ser enviado por diferentes canais ‚Äî WhatsApp, e-mail, webhook, SMS, etc. Se o c√≥digo estivesse rigidamente acoplado, seria necess√°rio criar uma classe espec√≠fica para cada combina√ß√£o poss√≠vel, como ComprovanteBasicoWhatsApp, ComprovanteDetalhadoEmail, ComprovanteFiscalWebhook e assim por diante. Isso geraria explos√£o de subclasses e alta complexidade de manuten√ß√£o.

Ao adotar o Bridge, criamos duas hierarquias independentes:

- Abstra√ß√£o ‚Üí Comprovante, ComprovanteBasico, ComprovanteDetalhado
Respons√°vel por definir o que deve ser enviado (estrutura e formato do comprovante).

- Implementa√ß√£o ‚Üí CanalEnvio, WhatsAppCanal, EmailCanal, WebhookCanal
Respons√°vel por definir como a mensagem ser√° transmitida.

A abstra√ß√£o mant√©m apenas uma refer√™ncia gen√©rica a um CanalEnvio. Assim, o mesmo comprovante pode ser utilizado com qualquer canal, e novos canais podem ser adicionados sem alterar as classes de comprovante ‚Äî basta ‚Äútrocar a ponte‚Äù.

Na execu√ß√£o, o objeto ComprovanteDetalhado monta o conte√∫do textual do pedido e o delega ao canal configurado (por exemplo, EmailCanal) para envio. Posteriormente, ele pode mudar dinamicamente para outro canal (WebhookCanal) sem qualquer modifica√ß√£o estrutural, apenas chamando o m√©todo trocarCanal().

Essa aplica√ß√£o ilustra perfeitamente o princ√≠pio descrito no padr√£o Bridge: permitir que abstra√ß√µes e implementa√ß√µes variem independentemente, tornando o sistema mais modular, extens√≠vel e f√°cil de evoluir.

Em resumo, o Bridge no PodePedirFCTE garante que o conceito de ‚Äúcomprovante‚Äù e o mecanismo de ‚Äúentrega‚Äù possam evoluir separadamente ‚Äî por exemplo, permitindo criar novos tipos de comprovante (fiscal, resumido, promocional) e novos canais (push, chatbot, integra√ß√£o ERP) sem quebrar o c√≥digo existente, mantendo o sistema flex√≠vel e preparado para futuras expans√µes.

---

#### Estrutura Sugerida

```md
podepedir-bridge/
  src/
    domain.ts
    bridge/
      implementor.ts       # Implementor + ConcreteImplementors (canais)
      abstraction.ts       # Abstraction + RefinedAbstractions (comprovantes)
    main.ts
  package.json
  tsconfig.json
```

#### 1) package.json

```json
{
  "name": "podepedir-bridge-demo",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "tsx src/main.ts",
    "dev": "tsx watch src/main.ts",
    "build": "tsc -p ."
  },
  "devDependencies": {
    "tsx": "^4.19.2",
    "typescript": "^5.6.3"
  }
}
```

#### 2) tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "outDir": "dist"
  },
  "include": ["src"]
}
```

#### 3) src/domain.ts

```ts
export type ID = string | number;

export interface ItemPedido {
  id: ID;
  nome: string;
  qtd: number;
  preco: number; // unit√°rio
}

export interface Pedido {
  id: ID;
  alunoNome: string;
  alunoContato: string;   // e-mail ou telefone
  fornecedorNome: string;
  taxaEntrega: number;
  itens: ItemPedido[];
  criadoEm: Date;
}

export function totalItens(p: Pedido) {
  return p.itens.reduce((s, i) => s + i.preco * i.qtd, 0);
}
export function totalGeral(p: Pedido) {
  return totalItens(p) + p.taxaEntrega;
}
```
#### 4) src/bridge/implementor.ts

```ts
// Implementor
export interface CanalEnvio {
  nome(): string;
  enviar(destino: string, conteudo: string, meta?: Record<string, unknown>): Promise<void>;
}

// ConcreteImplementor A: WhatsApp
export class WhatsAppCanal implements CanalEnvio {
  constructor(private fromNumber: string) {}
  nome() { return "WhatsApp"; }
  async enviar(destino: string, conteudo: string) {
    // simula√ß√£o de integra√ß√£o
    console.log(`üì± [WhatsApp] ${this.fromNumber} ‚Üí ${destino}\n${conteudo}\n`);
  }
}

// ConcreteImplementor B: Email
export class EmailCanal implements CanalEnvio {
  constructor(private remetente: string) {}
  nome() { return "Email"; }
  async enviar(destino: string, conteudo: string, meta?: Record<string, unknown>) {
    const assunto = meta?.assunto ?? "Comprovante do Pedido";
    console.log(`üìß [Email] ${this.remetente} ‚Üí ${destino}\nAssunto: ${assunto}\n${conteudo}\n`);
  }
}

// ConcreteImplementor C: Webhook (ex.: ERP/CRM)
export class WebhookCanal implements CanalEnvio {
  constructor(private endpoint: string) {}
  nome() { return "Webhook"; }
  async enviar(destino: string, conteudo: string) {
    // simula√ß√£o de POST
    console.log(`üîó [Webhook] POST ${this.endpoint} (destino=${destino})\nPayload:\n${conteudo}\n`);
  }
}
```

#### 5) src/bridge/abstraction.ts

```ts
import { Pedido, totalGeral, totalItens } from "../domain";
import { CanalEnvio } from "./implementor";

// Abstraction
export abstract class Comprovante {
  constructor(protected canal: CanalEnvio) {}
  abstract montarConteudo(pedido: Pedido): string;

  async enviar(pedido: Pedido) {
    const conteudo = this.montarConteudo(pedido);
    await this.canal.enviar(pedido.alunoContato, conteudo, {
      assunto: `Comprovante do Pedido #${pedido.id}`,
    });
  }

  canalAtual() { return this.canal; }
  trocarCanal(novo: CanalEnvio) { this.canal = novo; }
}

// RefinedAbstraction A: B√°sico
export class ComprovanteBasico extends Comprovante {
  montarConteudo(p: Pedido): string {
    return [
      `Pedido #${p.id} ‚Äî ${p.fornecedorNome}`,
      `Cliente: ${p.alunoNome}`,
      `Itens: ${p.itens.length} | Total Itens: R$ ${totalItens(p).toFixed(2)}`,
      `Taxa de entrega: R$ ${p.taxaEntrega.toFixed(2)}`,
      `Total: R$ ${totalGeral(p).toFixed(2)}`,
      `Criado em: ${p.criadoEm.toLocaleString()}`
    ].join("\n");
  }
}

// RefinedAbstraction B: Detalhado
export class ComprovanteDetalhado extends Comprovante {
  montarConteudo(p: Pedido): string {
    const itens = p.itens
      .map(i => ` - ${i.nome} x${i.qtd} = R$ ${(i.preco * i.qtd).toFixed(2)}`)
      .join("\n");
    return [
      `Pedido #${p.id}`,
      `Fornecedor: ${p.fornecedorNome}`,
      `Cliente: ${p.alunoNome}`,
      `\nItens:\n${itens}`,
      `\nSubtotal: R$ ${totalItens(p).toFixed(2)}`,
      `Taxa entrega: R$ ${p.taxaEntrega.toFixed(2)}`,
      `Total: R$ ${totalGeral(p).toFixed(2)}`,
      `Data/Hora: ${p.criadoEm.toLocaleString()}`
    ].join("\n");
  }
}
```

#### 6)src/main.ts

```ts
import { Pedido } from "./domain";
import { ComprovanteBasico, ComprovanteDetalhado } from "./bridge/abstraction";
import { EmailCanal, WhatsAppCanal, WebhookCanal } from "./bridge/implementor";

// Pedido de exemplo
const pedido: Pedido = {
  id: "P-2025-001",
  alunoNome: "Ana Silva",
  alunoContato: "ana.silva@fcte.br", // vai servir como "destino" gen√©rico
  fornecedorNome: "Cantina FCTE",
  taxaEntrega: 5.9,
  criadoEm: new Date(),
  itens: [
    { id: "i1", nome: "X-FCTE", qtd: 1, preco: 22 },
    { id: "i2", nome: "Suco Laranja", qtd: 2, preco: 8 }
  ]
};

async function run() {
  // Implementations (canais)
  const zap = new WhatsAppCanal("+5561999999999");
  const email = new EmailCanal("no-reply@podepedir.fcte");
  const hook = new WebhookCanal("https://api.parceiro.dev/webhook/pedidos");

  // Abstraction 1 + Implementor A
  const compBasicoViaZap = new ComprovanteBasico(zap);
  await compBasicoViaZap.enviar({ ...pedido, alunoContato: "+5561988888888" });

  // Abstraction 2 + Implementor B
  const compDetalhadoViaEmail = new ComprovanteDetalhado(email);
  await compDetalhadoViaEmail.enviar(pedido);

  // Trocar implementa√ß√£o em tempo de execu√ß√£o (Bridge em a√ß√£o)
  compDetalhadoViaEmail.trocarCanal(hook);
  await compDetalhadoViaEmail.enviar({ ...pedido, alunoContato: "erp.parceiro" });

  // Outra combina√ß√£o ainda: B√°sico por Email
  compBasicoViaZap.trocarCanal(email);
  await compBasicoViaZap.enviar(pedido);
}

run().catch(console.error);
```

---

### Execu√ß√£o

O v√≠deo a seguir ilusta a execu√ß√£o do c√≥digo acima. [Link de acesso.](#)

---

## Hist√≥rico de Vers√µes

| **Data**       | **Vers√£o** | **Descri√ß√£o**                         | **Autor**                                      | **Revisor**                                      | **Data da Revis√£o** |
| :--------: | :----: | :-------------------------------- | :----------------------------------------: | :----------------------------------------: | :-------------: |
| 21/10/2025 |  `1.0`   | Cria√ß√£o da p√°gina. | [`@storch7`](https://github.com/storch7) | [`@`]() |   --/--/----    |
# GoF Criacional - Multiton

## Definição

O **Multiton** é um padrão **criacional** que generaliza o *Singleton*:  
em vez de apenas uma instância global, ele mantém **múltiplas instâncias únicas**, **uma por chave**.  

Cada chave representa um contexto (ex.: ambiente, região, módulo, cliente) e o padrão garante que **todas as requisições com a mesma chave retornem o mesmo objeto**.  
Esse conceito deriva das variações do padrão *Singleton* apresentadas por Gamma et al. (1995), no contexto de criação controlada de objetos.

---

## Motivação

Em sistemas complexos, há cenários em que é necessário:
- manter **configurações isoladas por ambiente** (`DEV`, `HOMOLOG`, `PROD`);
- gerenciar **conexões específicas por região** (ex.: BR-SP, BR-DF);
- representar **clientes ou tenants** distintos em uma arquitetura SaaS.

De acordo com Gamma et al. (1995), padrões criacionais como *Singleton*, *Factory Method* e *Multiton* visam encapsular a lógica de criação, promovendo baixo acoplamento e controle do ciclo de vida dos objetos.  
Nesse contexto, o Multiton centraliza e controla a criação desses objetos, evitando duplicidade e reduzindo custo de inicialização.

---

## Benefícios

| Categoria         | Ganho                                                |
| ----------------- | ---------------------------------------------------- |
| **Controle**      | Criação centralizada e única por contexto.           |
| **Eficiência**    | Reuso de objetos caros (banco, cache, API client).   |
| **Consistência**  | Todos os módulos usam a mesma instância da chave.    |
| **Flexibilidade** | Adapta-se a sistemas multi-ambiente ou multi-tenant. |

Segundo Larman (2007), padrões de projeto criacionais ajudam a tornar o sistema mais coeso e fácil de evoluir, pois isolam as decisões de instanciação e favorecem a extensão sem modificação do código existente (*Open/Closed Principle*).

---

## Riscos e Cuidados

- **Concorrência:** use estruturas *thread-safe* (`ConcurrentHashMap`, `computeIfAbsent`).  
- **Acúmulo:** sem política de expiração, o mapa pode crescer indefinidamente.  
- **Acoplamento global:** o acesso estático deve ser bem justificado; prefira injeção via DI quando possível.  

Pressman (2006) alerta que o uso excessivo de padrões pode introduzir complexidade desnecessária se aplicado fora do contexto correto.  
Por isso, o Multiton deve ser utilizado apenas quando há clara necessidade de controle de instâncias por contexto.

---

## Comparação com Padrões Relacionados

| Padrão          | Diferença principal                                          |
| --------------- | ------------------------------------------------------------ |
| **Singleton**   | Uma instância global única.                                  |
| **Multiton**    | Uma instância por chave/contexto.                            |
| **Object Pool** | Várias instâncias reutilizáveis, não únicas.                 |
| **Flyweight**   | Compartilha objetos imutáveis leves, sem controle por chave. |

Gamma et al. (1995) destacam que esses padrões, apesar de semelhantes na aparência, diferem no controle de estado e na responsabilidade de gerenciar o ciclo de vida dos objetos.

---

## Quando Usar

- Há necessidade de instâncias únicas por contexto.  
- Criação de objetos é custosa e reuso é vantajoso.  
- Deseja-se controle e visibilidade sobre objetos criados dinamicamente.  

## Quando Evitar

- Se há apenas um contexto (use **Singleton**).  
- Se o sistema é simples ou *stateless*.  
- Se o padrão introduz dependências globais desnecessárias.  

Larman (2007) reforça que a escolha do padrão deve considerar o impacto na testabilidade e manutenibilidade.  
O Multiton é útil em sistemas corporativos complexos, mas inadequado em aplicações pequenas ou orientadas a microserviços, onde o *lifetime* dos objetos é naturalmente controlado por containers de injeção de dependência.

---

## Aplicação no projeto

Com base no cenário de estudo proposto para esta disciplina, foi criado a seguinte estrutura de código para ilustrar a sua aplicação, levando em consideração o [Diagrama de Classes](#) da entrega 2.

### Multiton - Pode pedir FCTE

Neste exemplo de aplicação prático, o Multiton foi utilizado para controlar e otimizar a criação de objetos que representam contextos únicos no sistema, evitando duplicidade e garantindo reuso eficiente. O Multiton atua como um gerenciador central que cria e armazena instâncias com base em uma chave identificadora — por exemplo, o ID de um fornecedor, o tipo de pagamento ou o identificador de um cardápio. Assim, o sistema assegura que exista uma única instância ativa por chave, o que reduz consumo de memória e melhora o desempenho ao evitar buscas repetidas no banco de dados.

Na prática, isso se reflete em três principais aplicações dentro do projeto:

- O FornecedorContextMultiton, cuja chave é o fornecedorId, mantém em memória o contexto de cada fornecedor ativo, contendo informações como cardápio, horário de funcionamento, tempo médio de preparo e taxa de entrega. Dessa forma, sempre que o mesmo fornecedor for consultado novamente, o sistema reutiliza o mesmo objeto em vez de reconstruí-lo.

- O PaymentProcessorMultiton utiliza o tipo de pagamento (CARTAO, PIX ou CUPOM) como chave e garante que exista uma única instância responsável por processar cada modalidade, evitando reconfigurações desnecessárias de clientes e rotas de integração a cada transação.

- Já o CardapioReadModelMultiton armazena versões em cache dos cardápios mais acessados, com o idCardapio como chave, agilizando o carregamento dos menus e reduzindo o acesso ao repositório de dados.

O funcionamento é simples: quando a aplicação solicita um contexto por meio de algo como FornecedorContextMultiton.getInstance("f1"), o sistema verifica se já existe uma instância para aquele fornecedor. Se existir e ainda estiver válida, ela é retornada imediatamente (cache hit). Caso contrário, uma nova instância é criada, armazenada e retornada (cache miss). Isso garante que todas as chamadas subsequentes para o mesmo identificador reutilizem a mesma instância, mantendo a consistência das informações durante o ciclo de vida da aplicação.

---

#### Estrutura Sugerida

```md
podepedir-fcte/
  src/
    domain.ts
    ports.ts
    cache.ts
    fornecedor-context.ts
    payment.ts
    cardapio-readmodel.ts   // opcional
    stubs/
      mem-repos.ts
      mem-estoque.ts
    checkout.ts
    place-order.ts
    main.ts
  package.json
  tsconfig.json

````

#### 1) package.json

```json
{
  "name": "podepedir-fcte-demo",
  "version": "1.0.0",
  "type": "module",
  "scripts": {
    "start": "tsx src/main.ts",
    "dev": "tsx watch src/main.ts",
    "build": "tsc -p ."
  },
  "dependencies": {},
  "devDependencies": {
    "tsx": "^4.19.2",
    "typescript": "^5.6.3"
  }
}
```

#### 2) tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "outDir": "dist"
  },
  "include": ["src"]
}
```

#### 3) src/domain.ts

```TS
export type ID = number | string;

export interface Usuario {
  username: string;
  senha: string;
  email: string;
  telefone: string;
}

export interface Aluno extends Usuario {
  nome: string;
  cpf: string;
}

export interface Fornecedor {
  id: ID;
  nomeFantasia: string;
  razaoSocial: string;
  cnpj: string;
  email: string;
  telefone: string;
  endereco: string;
  horarioFuncionamento: string; // "Seg-Dom 10:00-22:00"
  categoria: string;
  status: boolean;
  taxaEntrega: number;
  mediaPreparoMin: number;
  idCardapio: ID;
}

export interface Cardapio {
  idCardapio: ID;
  titulo: string;
  descricao: string;
  dataCriacao: Date;
  status: string;
  itens: Item[];
}

export interface Item {
  idItem: ID;
  nome: string;
  descricao: string;
  preco: number;
  categoria: string;
  disponibilidade: boolean;
  tempoPreparo: number;
  imagemUrl?: string;
}

export enum StatusPagamento { PENDENTE, APROVADO, RECUSADO, CANCELADO }
export enum TipoPagamento { CARTAO = 'CARTAO', PIX = 'PIX', CUPOM = 'CUPOM' }
export enum StatusEntrega { ACEITO, PREPARANDO, A_CAMINHO, ENTREGUE }

export interface Pagamento {
  idPagamento: ID;
  valorTotal: number;
  tipo: TipoPagamento;
  status: StatusPagamento;
  meta?: Record<string, unknown>;
}

export interface Pedido {
  id: ID;
  dataHora: Date;
  taxaEntrega: number;
  previsaoEntrega: Date;
  statusEntrega: StatusEntrega;
  alunoId: ID;
  fornecedorId: ID;
  itens: Array<{ itemId: ID; qtd: number }>;
}
```

#### 4) src/ports.ts

```TS
import { ID, Cardapio, Fornecedor, Item } from './domain';

export interface FornecedorRepository {
  loadFornecedor(id: ID): Promise<Fornecedor | null>;
}

export interface CardapioRepository {
  loadCardapio(id: ID): Promise<Cardapio | null>;
  loadItem(itemId: ID): Promise<Item | null>;
}

export interface EstoqueService {
  hasStock(fornecedorId: ID, itemId: ID, qtd: number): Promise<boolean>;
}

export interface Relogio { now(): Date; }
export class SystemClock implements Relogio { now() { return new Date(); } }
```

#### 5) src/cache.ts

```TS
type Entry<K, V> = { key: K; value: V; at: number };

export class LruMap<K, V> {
  private map = new Map<K, Entry<K, V>>();
  constructor(private capacity: number) {}

  get size() { return this.map.size; }

  get(key: K): V | undefined {
    const e = this.map.get(key);
    if (!e) return undefined;
    this.map.delete(key);
    this.map.set(key, { ...e, at: Date.now() });
    return e.value;
  }

  set(key: K, value: V) {
    if (this.map.has(key)) this.map.delete(key);
    this.map.set(key, { key, value, at: Date.now() });
    if (this.map.size > this.capacity) {
      const lruKey = this.map.keys().next().value;
      this.map.delete(lruKey);
    }
  }

  delete(key: K) { this.map.delete(key); }
  clear() { this.map.clear(); }
}
```

#### 6) src/fornecedor-context.ts

```TS
import { ID, Fornecedor, Pedido, StatusEntrega, Cardapio } from './domain';
import { CardapioRepository, EstoqueService, FornecedorRepository, Relogio, SystemClock } from './ports';
import { LruMap } from './cache';

export type Metrics = { hits: number; misses: number; evictions: number; refreshes: number };

export class FornecedorContext {
  private lastRefresh: number;
  constructor(
    public fornecedor: Fornecedor,
    public cardapio: Cardapio,
  ) { this.lastRefresh = Date.now(); }

  isOpen(now: Date = new Date()): boolean {
    return this.fornecedor.status && !!this.fornecedor.horarioFuncionamento;
  }

  async canFulfill(
    itens: Array<{ itemId: ID; qtd: number }>,
    estoque: EstoqueService
  ): Promise<boolean> {
    const rs = await Promise.all(itens.map(i => estoque.hasStock(this.fornecedor.id, i.itemId, i.qtd)));
    return rs.every(Boolean);
  }

  calcularFrete(): number { return this.fornecedor.taxaEntrega; }

  estimarEntregaMinutos(): number {
    const preparo = Math.max(
      this.fornecedor.mediaPreparoMin,
      ...this.cardapio.itens.filter(i => i.disponibilidade).map(i => i.tempoPreparo)
    );
    return Math.max(15, Math.min(preparo, 90));
  }

  markRefreshed() { this.lastRefresh = Date.now(); }
  isStale(ttlMs: number): boolean { return Date.now() - this.lastRefresh > ttlMs; }
}

export class FornecedorContextMultiton {
  private static _instance: FornecedorContextMultiton;
  static instance(): FornecedorContextMultiton {
    if (!this._instance) this._instance = new FornecedorContextMultiton();
    return this._instance;
  }

  private cache: LruMap<ID, FornecedorContext>;
  private metrics: Metrics = { hits: 0, misses: 0, evictions: 0, refreshes: 0 };

  private constructor(
    private ttlMs = 5 * 60 * 1000,
    private capacity = 200,
    private clock: Relogio = new SystemClock()
  ) { this.cache = new LruMap<ID, FornecedorContext>(capacity); }

  getMetrics() { return { ...this.metrics, size: this.cache.size, ttlMs: this.ttlMs, capacity: this.capacity }; }

  async getInstance(
    fornecedorId: ID,
    deps: { fornecedorRepo: FornecedorRepository; cardapioRepo: CardapioRepository; }
  ): Promise<FornecedorContext | null> {
    let ctx = this.cache.get(fornecedorId);
    if (ctx && !ctx.isStale(this.ttlMs)) {
      this.metrics.hits++;
      return ctx;
    }
    const fornecedor = await deps.fornecedorRepo.loadFornecedor(fornecedorId);
    if (!fornecedor) return null;
    const cardapio = await deps.cardapioRepo.loadCardapio(fornecedor.idCardapio);
    if (!cardapio) return null;

    ctx = new FornecedorContext(fornecedor, cardapio);
    ctx.markRefreshed();
    this.cache.set(fornecedorId, ctx);
    this.metrics.misses++;
    return ctx;
  }

  evict(fornecedorId: ID) { this.cache.delete(fornecedorId); this.metrics.evictions++; }
  clear() { this.cache.clear(); }
  setTtl(ms: number) { this.ttlMs = ms; }
  setCapacity(n: number) { this.capacity = n; this.cache = new LruMap<ID, FornecedorContext>(n); }
}
```

#### 7) src/payment.ts

```TS
import { Pagamento, Pedido, StatusPagamento, TipoPagamento } from './domain';

export interface PaymentProcessor {
  autorizar(pag: Pagamento, ped: Pedido): Promise<StatusPagamento>;
  capturar(pag: Pagamento, ped: Pedido): Promise<StatusPagamento>;
  estornar(pag: Pagamento, ped: Pedido): Promise<StatusPagamento>;
}

class CartaoProcessor implements PaymentProcessor {
  async autorizar() { return StatusPagamento.APROVADO; }
  async capturar()  { return StatusPagamento.APROVADO; }
  async estornar()  { return StatusPagamento.CANCELADO; }
}

class PixProcessor implements PaymentProcessor {
  async autorizar() { return StatusPagamento.PENDENTE; }
  async capturar()  { return StatusPagamento.APROVADO; }
  async estornar()  { return StatusPagamento.CANCELADO; }
}

class CupomProcessor implements PaymentProcessor {
  async autorizar() { return StatusPagamento.APROVADO; }
  async capturar()  { return StatusPagamento.APROVADO; }
  async estornar()  { return StatusPagamento.CANCELADO; }
}

export class PaymentProcessorMultiton {
  private static readonly procs: Record<TipoPagamento, PaymentProcessor> = {
    [TipoPagamento.CARTAO]: new CartaoProcessor(),
    [TipoPagamento.PIX]:    new PixProcessor(),
    [TipoPagamento.CUPOM]:  new CupomProcessor(),
  };
  static get(tipo: TipoPagamento): PaymentProcessor { return this.procs[tipo]; }
}
```

#### 8) src/checkout.ts

```TS
import { Pedido, StatusEntrega } from './domain';
import { FornecedorContextMultiton } from './fornecedor-context';
import { EstoqueService, CardapioRepository, FornecedorRepository } from './ports';

export async function prepararPedido(
  pedido: Pick<Pedido, 'fornecedorId' | 'itens'>,
  deps: { fornecedorRepo: FornecedorRepository; cardapioRepo: CardapioRepository; estoque: EstoqueService; }
) {
  const multi = FornecedorContextMultiton.instance();
  const ctx = await multi.getInstance(pedido.fornecedorId, {
    fornecedorRepo: deps.fornecedorRepo,
    cardapioRepo: deps.cardapioRepo
  });
  if (!ctx) throw new Error('Fornecedor não encontrado.');
  if (!ctx.isOpen()) throw new Error('Fornecedor fechado.');

  const ok = await ctx.canFulfill(pedido.itens, deps.estoque);
  if (!ok) throw new Error('Disponibilidade insuficiente.');

  const frete = ctx.calcularFrete();
  const minutos = ctx.estimarEntregaMinutos();

  return { frete, minutos, statusEntrega: StatusEntrega.ACEITO as const };
}
```

#### 9) src/place-order.ts

```TS
import { Pedido, Pagamento, StatusPagamento, TipoPagamento } from './domain';
import { prepararPedido } from './checkout';
import { PaymentProcessorMultiton } from './payment';
import { CardapioRepository, EstoqueService, FornecedorRepository } from './ports';

export async function placeOrder(
  draft: Pick<Pedido, 'fornecedorId' | 'alunoId' | 'itens'> & {
    tipoPagamento: TipoPagamento; valorItens: number;
  },
  deps: { fornecedorRepo: FornecedorRepository; cardapioRepo: CardapioRepository; estoque: EstoqueService; }
) {
  const prep = await prepararPedido({ fornecedorId: draft.fornecedorId, itens: draft.itens }, deps);
  const total = draft.valorItens + prep.frete;

  const pagamento: Pagamento = {
    idPagamento: crypto.randomUUID(),
    valorTotal: total,
    tipo: draft.tipoPagamento,
    status: StatusPagamento.PENDENTE
  };

  const pedido: Pedido = {
    id: crypto.randomUUID(),
    dataHora: new Date(),
    taxaEntrega: prep.frete,
    previsaoEntrega: new Date(Date.now() + prep.minutos * 60_000),
    statusEntrega: prep.statusEntrega,
    alunoId: draft.alunoId,
    fornecedorId: draft.fornecedorId,
    itens: draft.itens
  };

  const proc = PaymentProcessorMultiton.get(pagamento.tipo);
  pagamento.status = await proc.autorizar(pagamento, pedido);

  return { pedido, pagamento, resumo: { total, previsaoMin: prep.minutos } };
}
```

#### 10) src/stubs/mem-repos.ts

```TS
import { Cardapio, Fornecedor, ID } from '../domain';
import { CardapioRepository, FornecedorRepository } from '../ports';

const cardapios: Record<string, Cardapio> = {
  "c1": {
    idCardapio: "c1",
    titulo: "Lanches FCTE",
    descricao: "Clássicos do campus",
    dataCriacao: new Date(),
    status: "ATIVO",
    itens: [
      { idItem: "i1", nome: "X-FCTE", descricao: "hambúrguer da casa", preco: 22, categoria: "LANCHES", disponibilidade: true, tempoPreparo: 20 },
      { idItem: "i2", nome: "Suco",   descricao: "laranja",            preco: 8,  categoria: "BEBIDAS", disponibilidade: true, tempoPreparo: 2  },
      { idItem: "i3", nome: "Brownie",descricao: "chocolate",          preco: 10, categoria: "SOBREMESA", disponibilidade: false, tempoPreparo: 5 }
    ]
  }
};

const fornecedores: Record<string, Fornecedor> = {
  "f1": {
    id: "f1",
    nomeFantasia: "Cantina da FCTE",
    razaoSocial: "Cantina FCTE LTDA",
    cnpj: "00.000.000/0001-00",
    email: "contato@cantina.fcte",
    telefone: "61 99999-9999",
    endereco: "Campus FCTE, Bloco A",
    horarioFuncionamento: "Seg-Dom 09:00-22:00",
    categoria: "LANCHES",
    status: true,
    taxaEntrega: 5.9,
    mediaPreparoMin: 18,
    idCardapio: "c1"
  }
};

export class MemFornecedorRepo implements FornecedorRepository {
  async loadFornecedor(id: ID) { return fornecedores[String(id)] ?? null; }
}

export class MemCardapioRepo implements CardapioRepository {
  async loadCardapio(id: ID) { return cardapios[String(id)] ?? null; }
  async loadItem(itemId: ID) {
    const all = Object.values(cardapios).flatMap(c => c.itens);
    return all.find(i => String(i.idItem) === String(itemId)) ?? null;
  }
}
```

#### 11) src/stubs/mem-estoque.ts

```TS
import { EstoqueService, } from '../ports';
import { ID } from '../domain';

// estoque fake: i1 e i2 sempre têm; i3 não
export class MemEstoque implements EstoqueService {
  async hasStock(_fornecedorId: ID, itemId: ID, qtd: number): Promise<boolean> {
    if (String(itemId) === "i3") return false;
    return qtd <= 5; // limite simples
  }
}
```

#### 12) src/main.ts

```TS
import { placeOrder } from './place-order';
import { MemCardapioRepo, MemFornecedorRepo } from './stubs/mem-repos';
import { MemEstoque } from './stubs/mem-estoque';
import { FornecedorContextMultiton } from './fornecedor-context';
import { TipoPagamento } from './domain';

const fornecedorRepo = new MemFornecedorRepo();
const cardapioRepo = new MemCardapioRepo();
const estoque = new MemEstoque();

async function run() {
  const deps = { fornecedorRepo, cardapioRepo, estoque };

  console.log("=== 1ª compra (cache miss esperado) ===");
  const r1 = await placeOrder(
    {
      fornecedorId: "f1",
      alunoId: "a1",
      itens: [{ itemId: "i1", qtd: 1 }, { itemId: "i2", qtd: 2 }],
      tipoPagamento: TipoPagamento.CARTAO,
      valorItens: 22 + 2*8
    },
    deps
  );
  console.log(JSON.stringify(r1.resumo, null, 2));

  console.log("\n=== 2ª compra (mesmo fornecedor → cache hit) ===");
  const r2 = await placeOrder(
    {
      fornecedorId: "f1",
      alunoId: "a2",
      itens: [{ itemId: "i1", qtd: 2 }],
      tipoPagamento: TipoPagamento.PIX,
      valorItens: 2*22
    },
    deps
  );
  console.log(JSON.stringify(r2.resumo, null, 2));

  // métricas do Multiton
  const metrics = FornecedorContextMultiton.instance().getMetrics();
  console.log("\n=== Métricas Multiton ===");
  console.table(metrics);
}

run().catch(e => console.error(e));
```

---

### Execução

O vídeo a seguir ilusta a execução do código acima. [Link de acesso.](#)

---
## Referências

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. *Design patterns: elements of reusable object-oriented software.* Reading, MA: Addison-Wesley, 1995.  

> LARMAN, Craig. *Utilizando UML e padrões: uma introdução à análise e ao projeto orientados a objetos e ao desenvolvimento iterativo.* 3. ed. Porto Alegre: Bookman, 2007.  

> PRESSMAN, Roger S. *Engenharia de software: uma abordagem profissional.* 6. ed. São Paulo: McGraw-Hill, 2006.  

---

## Histórico de Versões

| **Data**       | **Versão** | **Descrição**                         | **Autor**                                      | **Revisor**                                      | **Data da Revisão** |
| :--------: | :----: | :-------------------------------- | :----------------------------------------: | :----------------------------------------: | :-------------: |
| 20/10/2025 |  `1.0`   | Criação da página. | [`@storch7`](https://github.com/storch7) | [`@Ana Joyce`](https://github.com/anajoyceamorim) |  24/10/2025  |
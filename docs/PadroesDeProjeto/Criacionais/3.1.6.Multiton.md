# GoF Criacional - Multiton

## Definição

O **Multiton** é um padrão **criacional** que generaliza o *Singleton*:  
em vez de apenas uma instância global, ele mantém **múltiplas instâncias únicas**, **uma por chave**.  

Cada chave representa um contexto (ex.: ambiente, região, módulo, cliente) e o padrão garante que **todas as requisições com a mesma chave retornem o mesmo objeto**.  
Esse conceito deriva das variações do padrão *Singleton* apresentadas por Gamma et al. (1995), no contexto de criação controlada de objetos.

---

## Motivação

Em sistemas complexos, há cenários em que é necessário:
- manter **configurações isoladas por ambiente** (`DEV`, `HOMOLOG`, `PROD`);
- gerenciar **conexões específicas por região** (ex.: BR-SP, BR-DF);
- representar **clientes ou tenants** distintos em uma arquitetura SaaS.

De acordo com Gamma et al. (1995), padrões criacionais como *Singleton*, *Factory Method* e *Multiton* visam encapsular a lógica de criação, promovendo baixo acoplamento e controle do ciclo de vida dos objetos.  
Nesse contexto, o Multiton centraliza e controla a criação desses objetos, evitando duplicidade e reduzindo custo de inicialização.

---

## Benefícios

| Categoria         | Ganho                                                |
| ----------------- | ---------------------------------------------------- |
| **Controle**      | Criação centralizada e única por contexto.           |
| **Eficiência**    | Reuso de objetos caros (banco, cache, API client).   |
| **Consistência**  | Todos os módulos usam a mesma instância da chave.    |
| **Flexibilidade** | Adapta-se a sistemas multi-ambiente ou multi-tenant. |

Segundo Larman (2007), padrões de projeto criacionais ajudam a tornar o sistema mais coeso e fácil de evoluir, pois isolam as decisões de instanciação e favorecem a extensão sem modificação do código existente (*Open/Closed Principle*).

---

## Riscos e Cuidados

- **Concorrência:** use estruturas *thread-safe* (`ConcurrentHashMap`, `computeIfAbsent`).  
- **Acúmulo:** sem política de expiração, o mapa pode crescer indefinidamente.  
- **Acoplamento global:** o acesso estático deve ser bem justificado; prefira injeção via DI quando possível.  

Pressman (2006) alerta que o uso excessivo de padrões pode introduzir complexidade desnecessária se aplicado fora do contexto correto.  
Por isso, o Multiton deve ser utilizado apenas quando há clara necessidade de controle de instâncias por contexto.

---

## Comparação com Padrões Relacionados

| Padrão          | Diferença principal                                          |
| --------------- | ------------------------------------------------------------ |
| **Singleton**   | Uma instância global única.                                  |
| **Multiton**    | Uma instância por chave/contexto.                            |
| **Object Pool** | Várias instâncias reutilizáveis, não únicas.                 |
| **Flyweight**   | Compartilha objetos imutáveis leves, sem controle por chave. |

Gamma et al. (1995) destacam que esses padrões, apesar de semelhantes na aparência, diferem no controle de estado e na responsabilidade de gerenciar o ciclo de vida dos objetos.

---

## Quando Usar

- Há necessidade de instâncias únicas por contexto.  
- Criação de objetos é custosa e reuso é vantajoso.  
- Deseja-se controle e visibilidade sobre objetos criados dinamicamente.  

## Quando Evitar

- Se há apenas um contexto (use **Singleton**).  
- Se o sistema é simples ou *stateless*.  
- Se o padrão introduz dependências globais desnecessárias.  

Larman (2007) reforça que a escolha do padrão deve considerar o impacto na testabilidade e manutenibilidade.  
O Multiton é útil em sistemas corporativos complexos, mas inadequado em aplicações pequenas ou orientadas a microserviços, onde o *lifetime* dos objetos é naturalmente controlado por containers de injeção de dependência.

---

## Referências

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. *Design patterns: elements of reusable object-oriented software.* Reading, MA: Addison-Wesley, 1995.  

> LARMAN, Craig. *Utilizando UML e padrões: uma introdução à análise e ao projeto orientados a objetos e ao desenvolvimento iterativo.* 3. ed. Porto Alegre: Bookman, 2007.  

> PRESSMAN, Roger S. *Engenharia de software: uma abordagem profissional.* 6. ed. São Paulo: McGraw-Hill, 2006.  

---

## Histórico de Versões

| **Data**       | **Versão** | **Descrição**                         | **Autor**                                      | **Revisor**                                      | **Data da Revisão** |
| :--------: | :----: | :-------------------------------- | :----------------------------------------: | :----------------------------------------: | :-------------: |
| 20/10/2025 |  `1.0`   | Criação da página. | [`@storch7`](https://github.com/storch7) | [`@`]() |   --/--/----    |
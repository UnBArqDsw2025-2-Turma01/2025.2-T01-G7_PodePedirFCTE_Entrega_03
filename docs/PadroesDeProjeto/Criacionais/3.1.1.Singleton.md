# 3.1.1. Singleton

## Introdução

Este documento tem como objetivo apresentar a aplicação do padrão de projeto Singleton, um dos padrões GoF (Gang of Four) (GAMMA et al., 1994), no contexto do sistema representado pelo diagrama de componentes fornecido. O padrão Singleton, conforme descrito pelo Refactoring Guru (2025), "permite a você garantir que uma classe tem apenas uma instância, enquanto provê um ponto de acesso global para esta instância". Ele é frequentemente aplicado em casos onde componentes únicos da aplicação precisam ser compartilhados por diferentes partes do sistema (SERRANO, 2025).

## Metodologia

Com base no escopo do sistema e no diagrama de componentes fornecido, foram analisadas diversas áreas em que a aplicação do padrão Singleton seria pertinente. A avaliação considerou critérios como centralização de controle, necessidade de uma única fonte de verdade e reutilização de instâncias compartilhadas.

Durante o processo de análise, foram considerados os seguintes candidatos ao uso de Singleton:

1.  **Orquestrador de Pedidos**
2.  **Gerenciador de Notificações**
3.  **Gerenciador de Pagamentos** (Para centralizar a comunicação com um gateway de pagamento único)
4.  **Gerenciador de Configurações** (Componente implícito para carregar variáveis de ambiente)
5.  **Um serviço de Logging centralizado**

Dentre esses, o **Orquestrador de Pedidos** foi selecionado como exemplo prático neste documento. A razão da escolha é que este componente representa o "cérebro" do ciclo de vida de um pedido, necessitando de um ponto único e centralizado de controle para coordenar múltiplos serviços (pagamentos, restaurantes, entregas) e garantir a consistência do estado dos pedidos, evitando condições de corrida ou processamento duplicado.

## Desenvolvimento

No projeto **Pode Pedir FCTE**, o padrão Singleton foi aplicado para garantir que exista apenas uma instância do `Orquestrador de Pedidos` em execução no backend. Isso centraliza a lógica de negócios complexa que coordena o status de um pedido entre múltiplos serviços, assegurando que toda modificação no fluxo de um pedido passe por este único ponto de controle.

A implementação foi feita utilizando o framework **NodeJs** com **completar**.  **completar**, 

### Estrutura do Singleton no Projeto

A implementação no projeto segue a estrutura clássica do padrão Singleton, conforme definido pelo GoF (GAMMA et al., 1994). Esta abordagem garante o controle explícito sobre a instanciação do componente, forçando o sistema a utilizar um único ponto de acesso.

A estrutura é dividida da seguinte forma:

* **A Classe Singleton:** A classe `OrquestradorDePedidos` é definida com duas características centrais:
    1.  Um **construtor privado**, que impede que qualquer outra classe ou componente externo crie instâncias dela diretamente usando o operador `new`.
    2.  Um **atributo estático e privado** que armazena a instância única da própria classe.

* **O Ponto de Acesso Global:** A classe `OrquestradorDePedidos` expõe um **método público estático**, comumente chamado de `getInstance()`. Este método é o único meio pelo qual o resto do sistema pode obter o objeto orquestrador (REFACTORING GURU, 2025). Internamente, este método verifica se a instância estática já foi criada. Se não foi (na primeira chamada), ele invoca o construtor privado para criar o objeto e o armazena no atributo estático. Em todas as chamadas subsequentes, ele simplesmente retorna a instância que já existe.

* **Os Consumidores do Singleton:** Qualquer outro componente do sistema (como um gerenciador de pagamentos ou um serviço de notificações) que precise interagir com o orquestrador, deve obrigatoriamente invocar o método estático `OrquestradorDePedidos.getInstance()` para obter a referência do objeto. Isso garante que, independentemente de quantos consumidores existam ou de onde eles estejam no código, todos estarão operando sobre a *mesma e única instância* do orquestrador (SERRANO, 2025), centralizando de fato o controle do fluxo dos pedidos..

##### Código Aplicado


```ts

Código...

```


<font size="2"><p style="text-align: center"><b>Figura 1:</b> Diagrama de classes representando o padrão Singleton (GoF)</p></font>


<div style="text-align: center;">


![figura1](assets/images/singleton_diag.png)


</div>


<font size="2"><p style="text-align: center"><b>Autor:</b> <a href="https://github.com/...">Nome</a>, 2025</p></font> 
 ## Demonstração do Código sendo Executado


- [Execução do Código](...)</br>

Participantes: ...</br>

- [Repositório do Codigo](...)


## Conclusão

A aplicação do padrão Singleton no Orquestrador de Pedidos demonstrou-se uma decisão de design acertada para o contexto do projeto Pode Pedir FCTE. Ao centralizar a lógica de coordenação do ciclo de vida dos pedidos em uma única instância, garantimos a consistência dos dados e evitamos conflitos de estado que poderiam surgir com múltiplas instâncias concorrentes.

A adoção da implementação do singleton através de um construtor privado e um método estático getInstance(), tornou a regra de negócio da "instância única" explícita e controlada diretamente pela própria classe OrquestradorDePedidos. Esta abordagem clássica (GAMMA et al., 1994) garante que o ponto de acesso global seja inequívoco e nos dá controle total sobre o ciclo de vida do objeto.

Embora esta implementação seja a forma canônica do padrão, estamos cientes de suas desvantagens notórias, como o acoplamento mais forte dos consumidores à classe concreta e os desafios que ela impõe aos testes unitários, como aponta o Refactoring Guru (2025). Contudo, para o propósito acadêmico de demonstrar o padrão e assegurar rigorosamente o controle centralizado do orquestrador, a escolha se justifica.

## Bibliografia

> Refactoring Guru. *Singleton*. Disponível em: [https://refactoring.guru/pt-br/design-patterns/singleton](https://refactoring.guru/pt-br/design-patterns/singleton). Acesso em: 27 maio 2025.

> SERRANO, Milene. AULA - GOFS CRIACIONAIS. Slides. Universidade de Brasília, 2025. Acesso em: 27 maio 2025.

> GAMMA, Erich; HELM, Richard; JOHNSON, Ralph; VLISSIDES, John. *Design Patterns: Elements of Reusable Object-Oriented Software*. Addison-Wesley, 1994.

> NESTJS. *Official Documentation*. Disponível em: [https://docs.nestjs.com](https://docs.nestjs.com)

> POSTGRESQL. *Node.js and PostgreSQL*. Disponível em: [https://node-postgres.com](https://node-postgres.com)

## Histórico de Versões

| Versão | Data       | Descrição                                                             | Autor(es)                                      | Revisor(es) | Detalhes da revisão |
| ------ | ---------- | --------------------------------------------------------------------- | ---------------------------------------------- | ----------- | ------------------- |
| 1.0    | 06/10/2025 | Inicialização do Documento com Introdução, Metodologia e Bibliografia | [Nathan Batista](https://github.com/Nathan-bs) |   [Cayo Alencar](https://github.com/Cayoalencar)          |A estrutura se demonstrou apropriada para a inclusão dos conteúdos , a bibliografia descrita foi a a utilizada no desenvolvimento da atividade  e a metodologia está de acordo com a adotada pelo grupo                    |
| 1.1    | 18/10/2025 | Preenchimento do Desenvolvimento e Conclusão focado no Orquestrador de Pedidos | [Cayo Alencar](https://github.com/Cayoalencar) |             |                     |
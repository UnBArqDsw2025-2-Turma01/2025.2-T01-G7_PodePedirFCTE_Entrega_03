# 3.1.7. Object Pool

O padrão **Object Pool** (Piscina de Objetos) é um padrão de projeto criacional que visa reduzir o custo computacional associado à criação e destruição de objetos, reutilizando instâncias que não estão em uso. Em vez de criar um novo objeto sempre que necessário e destruí-lo depois, o sistema "empresta" um objeto de um *pool* (uma piscina), usa-o e o "devolve" para que outros possam reutilizá-lo.

Este padrão é particularmente útil para objetos cuja inicialização é muito custosa, como conexões de banco de dados, *sockets* de rede ou *threads*.

## 1. Contexto no Projeto "PodePedirFCTE"

No contexto do nosso projeto, o **[PodePedirFCTE]**, a aplicação precisará lidar com um grande volume de requisições simultâneas ao banco de dados. Cada vez que um cliente faz um pedido, visualiza o cardápio ou fecha a conta, o sistema precisa interagir com o banco.

Abrir e fechar conexões com o banco de dados a cada interação é um processo lento e que consome muitos recursos. Como detalhado no **[Diagrama de Sequência](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G7_PodePedirFCTE_Entrega_02/#/Modelagem/ModelagemDinamica/DiagramaDeSequencia)** da segunda entrega, a comunicação com o banco é uma etapa crítica. Aplicar o padrão **Object Pool** para gerenciar um *pool* de conexões de banco de dados pode aumentar drasticamente a performance e a escalabilidade da aplicação.

## 2. Estrutura

O padrão é composto, em geral, pelas seguintes partes:

- **Reusable (Reutilizável):** O objeto que será armazenado no *pool*. A criação e destruição desses objetos são custosas.
- **Client (Cliente):** O objeto que precisa de uma instância do `Reusable`.
- **Object Pool (Piscina de Objetos):** A classe principal, que gerencia as instâncias do `Reusable`. Ela é responsável por:
    - Criar e armazenar os objetos.
    - Fornecer um objeto "livre" quando o `Client` solicita (`checkOut`).
    - Receber o objeto de volta quando o `Client` termina de usá-lo (`checkIn`).
    - Validar e expirar objetos que não são mais utilizáveis.

## 3. Exemplo de Implementação em C++

Apresentamos uma versão em C++ que segue a mesma lógica do padrão, mas utilizando recursos da linguagem C++ moderna, como templates, `std::shared_ptr` para gerenciamento de memória e `std::mutex` para garantir a segurança em ambientes com múltiplas threads.

### 3.1. Classe de Template `ObjectPool.h`

Este arquivo de cabeçalho define a classe de template `ObjectPool<T>`, que pode ser reutilizada para qualquer tipo de objeto. Ela usa templates para generalização.

```cpp
#ifndef OBJECT_POOL_H
#define OBJECT_POOL_H

#include <iostream>
#include <unordered_map>
#include <chrono>
#include <mutex>
#include <memory>

template <typename T>
class ObjectPool {
public:
    ObjectPool(long expirationTime = 30000) : expirationTime(expirationTime) {}

    virtual ~ObjectPool() = default;

    std::shared_ptr<T> checkOut() {
        std::lock_guard<std::mutex> lock(mutex_);
        long long now = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
        
        if (!unlocked.empty()) {
            for (auto it = unlocked.begin(); it != unlocked.end(); ) {
                auto obj = it->first;
                if ((now - it->second) > expirationTime) {
                    // Object has expired
                    it = unlocked.erase(it);
                    expire(obj);
                } else {
                    if (validate(obj)) {
                        it = unlocked.erase(it);
                        locked[obj] = now;
                        return obj;
                    } else {
                        // Object failed validation
                        it = unlocked.erase(it);
                        expire(obj);
                    }
                }
            }
        }

        // No objects available, create a new one
        auto newObj = create();
        locked[newObj] = now;
        return newObj;
    }

    void checkIn(std::shared_ptr<T> obj) {
        std::lock_guard<std::mutex> lock(mutex_);
        locked.erase(obj);
        unlocked[obj] = std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count();
    }

protected:
    virtual std::shared_ptr<T> create() = 0;
    virtual bool validate(std::shared_ptr<T> o) = 0;
    virtual void expire(std::shared_ptr<T> o) = 0;

private:
    long expirationTime;
    std::unordered_map<std::shared_ptr<T>, long long> locked, unlocked;
    std::mutex mutex_;
};

#endif // OBJECT_POOL_H
```

### 3.2. Utilização com uma Classe Simulada

O arquivo `main.cpp` demonstra como usar o `ObjectPool`. Para isso, criamos uma classe `DatabaseConnection` simulada e uma `ConnectionPool` concreta que herda de `ObjectPool<DatabaseConnection>`.

```cpp
#include <iostream>
#include <string>
#include <stdexcept>
#include "ObjectPool.h"

// Mock DatabaseConnection class
class DatabaseConnection {
public:
    DatabaseConnection(const std::string& dsn) : dsn_(dsn), is_closed_(false) {
        std::cout << "Connection created to " << dsn_ << std::endl;
    }

    void close() {
        if (!is_closed_) {
            std::cout << "Connection to " << dsn_ << " closed." << std::endl;
            is_closed_ = true;
        }
    }

    bool isClosed() const {
        return is_closed_;
    }

    void executeQuery(const std::string& query) {
        if (is_closed_) {
            throw std::runtime_error("Connection is closed");
        }
        std::cout << "Executing query: '" << query << "' on " << dsn_ << std::endl;
    }

private:
    std::string dsn_;
    bool is_closed_;
};

// Concrete implementation of ObjectPool for DatabaseConnection
class ConnectionPool : public ObjectPool<DatabaseConnection> {
public:
    ConnectionPool(const std::string& dsn) : dsn_(dsn) {}

protected:
    std::shared_ptr<DatabaseConnection> create() override {
        return std::make_shared<DatabaseConnection>(dsn_);
    }

    bool validate(std::shared_ptr<DatabaseConnection> o) override {
        return !o->isClosed();
    }

    void expire(std::shared_ptr<DatabaseConnection> o) override {
        o->close();
    }

private:
    std::string dsn_;
};

int main() {
    // Create the ConnectionPool
    ConnectionPool pool("my-database-server");

    // Get a connection
    std::cout << "Checking out a connection..." << std::endl;
    std::shared_ptr<DatabaseConnection> con1 = pool.checkOut();

    // Use the connection
    con1->executeQuery("SELECT * FROM users");

    // Get another connection
    std::cout << "\nChecking out a second connection..." << std::endl;
    std::shared_ptr<DatabaseConnection> con2 = pool.checkOut();
    con2->executeQuery("SELECT * FROM products");

    // Return the first connection
    std::cout << "\nChecking in the first connection..." << std::endl;
    pool.checkIn(con1);

    // Get a third connection - should reuse the first one
    std::cout << "\nChecking out a third connection..." << std::endl;
    std::shared_ptr<DatabaseConnection> con3 = pool.checkOut();
    con3->executeQuery("SELECT * FROM orders");

    // Return the remaining connections
    std::cout << "\nChecking in all connections..." << std::endl;
    pool.checkIn(con2);
    pool.checkIn(con3);

    std::cout << "\nPool example finished." << std::endl;

    return 0;
}
```
## Gravação da Apresentação

<iframe width="853" height="480" src="https://www.youtube.com/embed/yAIa2iySkBI" title="Pool" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

## Quadro de Participações

| **Membro da equipe** | **Função** |
| :------------- | :--------- |
| [Ana Joyce](https://github.com/anajoyceamorim) | Documentação e implementação do gof Criacional Pool |

## 5. Referências

- SOURCEMAKING. **Object Pool Design Pattern**. Disponível em: [https://sourcemaking.com/design_patterns/object_pool/java](https://sourcemaking.com/design_patterns/object_pool/java). Acesso em: 24 de out. de 2025.

## Histórico de Versões

| **Data**       | **Versão** | **Descrição**                         | **Autor**                                     | **Revisor** | **Data da Revisão** |
| :--------: | :----: | :-------------------------------- | :---------------------------------------: | :---------: | :-------------: |
| 24/10/2025 |  `1.0`   | Criação do artefato do Object Pool. | [Ana Joyce](https://github.com/anajoyceamorim) |   [Ana Clara](https://github.com/anabborges)          |     24/10/2025            |
| 24/10/2025 |  `1.1`   | Adição da estrutura de arquivos.    | [Ana Joyce](https://github.com/anajoyceamorim) |    [Ana Clara](https://github.com/anabborges)          |     24/10/2025            |

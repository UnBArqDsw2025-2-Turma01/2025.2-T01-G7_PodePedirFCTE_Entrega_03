
# 3.1.7. Object Pool

O padrão **Object Pool** (Piscina de Objetos) é um padrão de projeto criacional que visa reduzir o custo computacional associado à criação e destruição de objetos, reutilizando instâncias que não estão em uso. Em vez de criar um novo objeto sempre que necessário e destruí-lo depois, o sistema "empresta" um objeto de um *pool* (uma piscina), usa-o e o "devolve" para que outros possam reutilizá-lo.

Este padrão é particularmente útil para objetos cuja inicialização é muito custosa, como conexões de banco de dados, *sockets* de rede ou *threads*.

## 1. Contexto no Projeto "PodePedir!"

No contexto do nosso projeto, o **[PodePedir!](/Projeto/Projeto.md)**, a aplicação precisará lidar com um grande volume de requisições simultâneas ao banco de dados. Cada vez que um cliente faz um pedido, visualiza o cardápio ou fecha a conta, o sistema precisa interagir com o banco.

Abrir e fechar conexões com o banco de dados a cada interação é um processo lento e que consome muitos recursos. Como detalhado no **[Diagrama de Sequência](https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G7_PodePedirFCTE_Entrega_02/#/Modelagem/ModelagemDinamica/DiagramaDeSequencia)** da segunda entrega, a comunicação com o banco é uma etapa crítica. Aplicar o padrão **Object Pool** para gerenciar um *pool* de conexões de banco de dados (como `JDBCConnectionPool`) pode aumentar drasticamente a performance e a escalabilidade da aplicação.

## 2. Estrutura

O padrão é composto, em geral, pelas seguintes partes:

- **Reusable (Reutilizável):** O objeto que será armazenado no *pool*. A criação e destruição desses objetos são custosas.
- **Client (Cliente):** O objeto que precisa de uma instância do `Reusable`.
- **Object Pool (Piscina de Objetos):** A classe principal, que gerencia as instâncias do `Reusable`. Ela é responsável por:
    - Criar e armazenar os objetos.
    - Fornecer um objeto "livre" quando o `Client` solicita (`checkOut`).
    - Receber o objeto de volta quando o `Client` termina de usá-lo (`checkIn`).
    - Validar e expirar objetos que não são mais utilizáveis.

## 3. Exemplo de Implementação

O material de referência fornecido pela disciplina nos apresenta uma implementação em Java que se encaixa perfeitamente no nosso cenário. O exemplo demonstra como criar um *pool* para conexões JDBC (Java Database Connectivity).

### 3.1. Classe Abstrata `ObjectPool<T>`

Primeiro, define-se uma classe abstrata que contém a lógica principal de gerenciamento do *pool*. Ela controla quais objetos estão "emprestados" (`locked`) e quais estão "disponíveis" (`unlocked`), além de gerenciar o tempo de expiração de cada objeto.

```java
// ObjectPool Class
public abstract class ObjectPool<T> {
  private long expirationTime;

  private Hashtable<T, Long> locked, unlocked;

  public ObjectPool() {
    expirationTime = 30000; // 30 seconds
    locked = new Hashtable<T, Long>();
    unlocked = new Hashtable<T, Long>();
  }

  protected abstract T create();

  public abstract boolean validate(T o);

  public abstract void expire(T o);

  public synchronized T checkOut() {
    long now = System.currentTimeMillis();
    T t;
    if (unlocked.size() > 0) {
      Enumeration<T> e = unlocked.keys();
      while (e.hasMoreElements()) {
        t = e.nextElement();
        if ((now - unlocked.get(t)) > expirationTime) {
          // object has expired
          unlocked.remove(t);
          expire(t);
          t = null;
        } else {
          if (validate(t)) {
            unlocked.remove(t);
            locked.put(t, now);
            return (t);
          } else {
            // object failed validation
            unlocked.remove(t);
            expire(t);
            t = null;
          }
        }
      }
    }
    // no objects available, create a new one
    t = create();
    locked.put(t, now);
    return (t);
  }

  public synchronized void checkIn(T t) {
    locked.remove(t);
    unlocked.put(t, System.currentTimeMillis());
  }
}
```

### 3.2. Implementação Concreta `JDBCConnectionPool`

Em seguida, criamos uma subclasse que implementa os métodos abstratos (`create`, `validate`, `expire`) para um tipo específico de objeto: `Connection` (conexão de banco de dados).

- `create()`: Cria uma nova conexão com o banco.
- `validate()`: Verifica se a conexão ainda está aberta e válida.
- `expire()`: Fecha a conexão para removê-la do *pool*.

```java
public class JDBCConnectionPool extends ObjectPool<Connection> {

  private String dsn, usr, pwd;

  public JDBCConnectionPool(String driver, String dsn, String usr, String pwd) {
    super();
    try {
      Class.forName(driver).newInstance();
    } catch (Exception e) {
      e.printStackTrace();
    }
    this.dsn = dsn;
    this.usr = usr;
    this.pwd = pwd;
  }

  @Override
  protected Connection create() {
    try {
      return (DriverManager.getConnection(dsn, usr, pwd));
    } catch (SQLException e) {
      e.printStackTrace();
      return (null);
    }
  }

  @Override
  public void expire(Connection o) {
    try {
      ((Connection) o).close();
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }

  @Override
  public boolean validate(Connection o) {
    try {
      return (!((Connection) o).isClosed());
    } catch (SQLException e) {
      e.printStackTrace();
      return (false);
    }
  }
}
```

### 3.3. Utilização pelo Cliente

Finalmente, a aplicação cliente pode usar o `JDBCConnectionPool` para obter, usar e devolver conexões, sem se preocupar com os detalhes da criação ou do fechamento.

```java
public class Main {
  public static void main(String args[]) {
    // Do something...
    ...

    // Create the ConnectionPool:
    JDBCConnectionPool pool = new JDBCConnectionPool(
      "org.hsqldb.jdbcDriver", "jdbc:hsqldb://localhost/mydb",
      "sa", "secret");

    // Get a connection:
    Connection con = pool.checkOut();

    // Use the connection
    ...

    // Return the connection:
    pool.checkIn(con);
 
  }
}
```

## 4. Estrutura de Arquivos do Exemplo

Para organizar o código de exemplo em um projeto Java, seguiríamos a estrutura de pacotes padrão. Cada classe seria declarada em seu próprio arquivo `.java`.

Considerando um pacote base como `com.podepedir.pool`, a árvore de diretórios ficaria assim:

```
src/
└── main/
    └── java/
        └── com/
            └── podepedir/
                ├── pool/
                │   ├── ObjectPool.java
                │   └── JDBCConnectionPool.java
                └── Main.java
```

- **`ObjectPool.java`**: Conteria a classe abstrata `ObjectPool<T>`, que serve como a base para qualquer tipo de *pool* de objetos.
- **`JDBCConnectionPool.java`**: Conteria a implementação concreta para o *pool* de conexões de banco de dados.
- **`Main.java`**: Seria a classe cliente, responsável por instanciar e utilizar o `JDBCConnectionPool`.

Essa organização segue as convenções do Java, facilitando a manutenção e a escalabilidade do código, alinhando-se com os princípios de componentização vistos no **[Diagrama de Componentes](/https://unbarqdsw2025-2-turma01.github.io/2025.2-T01-G7_PodePedirFCTE_Entrega_02/#/Modelagem/ModelagemEstatica/DiagramaDeComponentes)**.

## 5. Referências

- SOURCEMAKING. **Object Pool Design Pattern**. Disponível em: [https://sourcemaking.com/design_patterns/object_pool/java](https://sourcemaking.com/design_patterns/object_pool/java). Acesso em: 24 de out. de 2025.

## Histórico de Versões

| **Data**       | **Versão** | **Descrição**                         | **Autor**                                     | **Revisor** | **Data da Revisão** |
| :--------: | :----: | :-------------------------------- | :---------------------------------------: | :---------: | :-------------: |
| 24/10/2025 |  `1.0`   | Criação do artefato do Object Pool. | [Ana Joyce](https://github.com/anajoyceamorim) |             |                 |
| 24/10/2025 |  `1.1`   | Adição da estrutura de arquivos.    | [Ana Joyce](https://github.com/anajoyceamorim) |             |                 |
